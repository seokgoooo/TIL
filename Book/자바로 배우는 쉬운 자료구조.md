# 1. 자료의 표현, 소프트웨어와 자료구조
- 효율적인 자료구조 선택할 때 고려사항
    - 표현하고자 하는 자료의 특성 & 양
    - 자료의 주된 사용 방법
    - 수행하는 연산의 종류
    - 구현에 필요한 메모리 용량
- 성공한 소프트웨어
    - 요구 기능을 정확하게 수행하는지
    - 변경사항을 쉽게 수용할 수 있는지
    - 외부의 공격에 대해 문제가 발생하지 않는 보안성을 갖추고
    - 사용자가 쉽게 사용법을 배우고 편하게 사용할 수 있는지

# 2. 객체지향 프로그래밍, 자바 프로그래밍

# 3. 순차 자료구조
- 0x03강 알파벳 배열문제 다시 풀어보자 무능함+1
- 배열의 성질
    1. O(1)에 k번째 원소를 확인/변경 가능
    2. 추가적으로 소모되는 메모리의 양(=overhead)가 거의 없음
    3. Cache hit rate가 높음
        - 적중률 = (캐시히트 횟수) / (전체참조 횟수)
    4. 메모리 상에 연속한 구간을 잡아야 해서 할당에 제약이 걸림
    - 배열을 활용하면 좋을 때
        1. 데이터 개수가 확실하게 정해져 있을 때 데이터 저장을 위한 자료구조
        2. 삽입/삭제 작업이 적을 때
        3. 배열에 저장된 데이터를 검색하는 작업이 많을 때 (인덱스로 빠른 검색 가능)
- 선형 리스트
    - 원소들 간의 논리적인 순서와 메모리에 저장하는 물리적인 순서가 같은 순차 자료구조 방식
    - 순차 자료구조 방식에서는 원소들이 순서대로 연속하여 저장된다.
- 다항식의 순차 자료구조
- 행렬의 순차 자료구조

# 4. 연결 자료구조
- 연결 리스트의 성질
    1. k번째 원소를 확인/변경하기 위해 O(k)가 필요함
    2. 임의의 위치에 원소를 추가/임의 위치의 원소 제거는 O(1)
    3. 원소들이 메모리 상에 연속해있지 않아 Cache hit rate가 낮지만 할당이 다소 쉬움
- 노드
    - <원소, 주소>의 단위인 구조
# 배열 vs 리스트
||배열|연결 리스트|
|:--|:--:|:--:|
|k번째 원소 접근|O(1)|O(k)|
|임의 위치에 원소 추가/제거|O(N)|O(1)|
|메모리 상의 배치|연속|불연속|
|추가적으로 필요한 공간(Overhead)|-|O(N)|

# 5. 스택
- 스택의 성질
    1. 원소의 추가 : O(1)
    2. 원소의 제거 : O(1)
    3. 제일 상단의 원소 확인 : O(1)
    4. 제일 상단이 아닌 나머지 원소들의 확인/변경이 원칙적으로 불가능
# 6. 큐
- 큐의 성질
    1. 원소의 추가 : O(1)
    2. 원소의 제거 : O(1)
    3. 제일 앞 / 뒤의 원소 확인 : O(1)
    4. 제일 앞 / 뒤가 아닌 나머지 원소들의 확인/변경이 원칙적으로 불가능

---

# 9. 트리
# 10. 트리, 그래프
# 11. 그래프
# 12. 정렬
# 13. 정렬
# 14. 검색
# 15. 검색